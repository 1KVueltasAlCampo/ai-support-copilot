# AI-Powered Support Co-Pilot | VIVETORI Technical Challenge

Este proyecto es una soluci√≥n integral de **Inteligencia Artificial Full-Stack** dise√±ada para optimizar la gesti√≥n de tickets de soporte. El sistema automatiza la clasificaci√≥n, el an√°lisis de sentimiento y la visualizaci√≥n en tiempo real de las solicitudes de los usuarios.

## üöÄ Enlaces del Proyecto

* **Dashboard Activo:** [ubiquitous-starlight-d753ba.netlify.app](https://ubiquitous-starlight-d753ba.netlify.app)
* **API de Python (Backend):** [https://ai-support-copilot-0im9.onrender.com](https://ai-support-copilot-0im9.onrender.com)

---

## üõ†Ô∏è Stack Tecnol√≥gico

* **Frontend:** React 18, TypeScript, Vite, Tailwind CSS, Lucide Icons.
* **Backend:** Python 3.10, FastAPI, Google GenAI SDK (Gemini 2.0 Flash).
* **Base de Datos:** Supabase (PostgreSQL) con capacidades de Realtime.
* **Automatizaci√≥n:** n8n (Workflow orchestration).
* **Infraestructura:** Render (API) y Netlify (Frontend).

---

## üß† Estrategia de Prompt Engineering

Para el n√∫cleo de procesamiento de lenguaje natural, se implement√≥ una estrategia avanzada de **Persona-Based Structured Prompting** optimizada para el modelo **Gemini 2.0 Flash**. Los pilares fundamentales son:

1. **Contextual Anchoring & Role Prompting:** Se defini√≥ un contexto de negocio espec√≠fico para VIVETORI, asignando al modelo el rol de "Agente de Inteligencia de Soporte". Esto alinea el tono y los criterios de clasificaci√≥n con los objetivos operativos de la empresa.
2. **Delimitadores de Seguridad:** Se utilizaron triple comillas (`"""`) para aislar la entrada del usuario (`ticket.description`). Esta t√©cnica de segmentaci√≥n previene ataques de *Prompt Injection* y ayuda al modelo a distinguir claramente entre instrucciones del sistema y datos a procesar.
3. **Salida Estructurada (Constraint Enforcement):** Se configur√≥ un **JSON Schema plano** inyectado directamente en el motor de inferencia del SDK de Google. Esto garantiza que la respuesta sea 100% compatible con los tipos `Enum` de PostgreSQL en Supabase, eliminando errores de parseo y garantizando la integridad de los datos.
4. **Determinismo T√©cnico:** El modelo se configur√≥ con una `temperature: 0.1`. Este valor extremadamente bajo asegura que el an√°lisis sea consistente y predecible, evitando variaciones creativas en la clasificaci√≥n de categor√≠as cr√≠ticas como "T√©cnico" o "Facturaci√≥n".
5. **L√≥gica de Priorizaci√≥n:** El prompt incluye reglas de decisi√≥n para casos ambiguos, instruyendo al modelo a priorizar etiquetas de alta urgencia o sentimientos negativos para disparar flujos cr√≠ticos en n8n.

---

## ‚öôÔ∏è Arquitectura del Sistema

1. **Ingesta:** Un ticket es insertado en la tabla `tickets` de Supabase.
2. **Orquestaci√≥n:** n8n detecta la nueva fila y consume el microservicio de Python.
3. **Inferencia:** FastAPI recibe el contenido, aplica la estrategia de Prompt Engineering y obtiene el an√°lisis estructurado de Gemini 2.0.
4. **Persistencia:** El microservicio actualiza la fila en Supabase mediante el cliente de **PostgREST**, marcando el ticket como procesado.
5. **Visualizaci√≥n:** El Dashboard de React, suscrito a los canales de **Supabase Realtime**, actualiza la interfaz instant√°neamente sin requerir interacci√≥n del usuario.
6. **Alerta:** Si el sentimiento es **"Negativo"**, el flujo de n8n dispara una notificaci√≥n autom√°tica por correo electr√≥nico.

---

## üìÇ Estructura del Repositorio

* `/supabase`: Esquema de base de datos (`setup.sql`) y pol√≠ticas de seguridad.
* `/python-api`: Microservicio FastAPI, modelos de Pydantic y configuraci√≥n de IA.
* `/n8n-workflow`: Exportaci√≥n del flujo de automatizaci√≥n en formato JSON.
* `/frontend`: C√≥digo fuente del Dashboard interactivo.

---

**Desarrollado por Juan David Cruz Garcia** - *Ingeniero de Sistemas*